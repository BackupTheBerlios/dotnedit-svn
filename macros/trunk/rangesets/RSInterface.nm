# ======================================================================
# Adapt $RSI_globals["color-list"]: specify path to rangesetRgb.txt file !
# ======================================================================
#
# ======================================================================
# This file contains the following interface procedures:
# ======================================================================
# RSI_info
# RSI_add
# RSI_remove_selected
# RSI_remove_all
# RSI_color
# RSI_rename
# RSI_destroy
# RSI_destroy_any
# RSI_save
# RSI_load
# RSI_find_all
# RSI_goto_next
# RSI_goto_next_choose
# RSI_goto_prev
# RSI_show_changes  --  [requires wdiff]
# ======================================================================
# This file contains the following sub procedures:
# ======================================================================
# RSI_allocate_predef
# RSI_list_names
# RSI_ask_for_name
# RSI_verify_name
# RSI_get_id
# RSI_rename_in_all_windows
# RSI_rename_in_window
# RSI_define_new
# RSI_allocate_new
# RSI_destroy_name
# RSI_destroy_name_all
# RSI_select
# RSI_choose_color
# RSI_get_color
# RSI_set_color
# RSI_add_selection
# RSI_get_next_pos
# RSI_get_prev_pos
# RSI_exists
# RSI_store_inline
# RSI_store_in_file
# RSI_write
# RSI_read_inline
# RSI_read_from_file
# RSI_read
# RSI_read_set
# RSI_read_block
# RSI_get_line_info
# ======================================================================
# All global variables used are stored in the array $RSI_globals
# ======================================================================


# ======================================================================
# === Initialization ===================================================
# ======================================================================

# Depends on  $jf_path_to and *jf_require*() defined in 
# autoload.nm, cf. macro setup.
# Depends on  $jf_path_to and jf_require() defined in 
# autoload.nm, cf. macro setup.
errMsg = "WARNING:\nThe \""$file_name"\" file is tied to a special path setup,\n"\
           "given by a special \"autoload.nm\" file.  The latter file\n"\
           "seems to be missing or changed."
$jf_path_to[""] = 0
if (!("/NEDIT_HOME/" in $jf_path_to)) {
   calltip(errMsg)
}


$RSI_globals["color-list"] = $jf_path_to["RSInterface.nm"] "rangesetRgb.txt"

# Unique prefix to ensure we don't mess up with different rangeset
# macro sets. 
# NOTICE:  RSI accesses all its rangesets only via the rangeset name!
$RSI_globals["NAME-PREFIX"] = "uRSi5_"
$RSI_globals["name-prefix"] = $RSI_globals["NAME-PREFIX"]
# List of predefined rangeset names and colors separated by \n.  
# Both lists should have the same length.
# Here the rangeset named "Marks01" is colored in yellow, "Marks02" in
# orange, and "Found" in LigthGreen.  ("Found" is used for Find All.)
$RSI_globals["predef-names"] = "Marks01\nMarks02\nFound"
$RSI_globals["predef-colors"] = "yellow\norange\nLightGreen"

# Allocates the preceding predefined names and colors to rangesets.
define RSI_allocate_predef {
  allocated = 0
  
  names = split($RSI_globals["predef-names"], "\n")
  colors = split($RSI_globals["predef-colors"], "\n")
  
  nbr = min(names[], colors[])
  
  for (i = 0; i < nbr; i++) {
      if (RSI_allocate_new( names[i], colors[i] ))
            allocated++
      else
        dialog("RSI_allocate_predef: Warning, couldn't allocate predefined rangeset\n\n"\
            names[i])
  }
  if (allocated)
      return 1
  else
      return 0

}


# ======================================================================
# === Interface procedures =============================================
# ======================================================================

# Show Information about ALL (not only defined by RSI) rangesets in the
# current window.

define RSI_info {
  r = $rangeset_list
  list = ""
  for (i=0; i < r[]; i++) {
   a = rangeset_info(r[i])
   list = list i+1 ": " a["name"] "  :  " a["color"] "  :  " a["count"] "\n"
  }
  if (length(list) > 0)
    list = substring(list, 0, length(list) - 1)
  message = "There are *"r[]"* rangesets defined.\n[maximally supported: 63]\n"\
            "These are (Name : Color : # ranges in set):\n"\
            "-------------------------------------------\n" list
  calltip(message)
}


# -----------------------------------------------------------------------
# RSI_add():
# Add the selected text to a rangeset, which is chosen by dialog.  If
# there is no selection, acts automagically, cf. the subsequent comments.
# (This is part of a simple and quick next/previous mark functionality.)
# -----------------------------------------------------------------------

define RSI_add {

  if ($selection_start == -1) {
      # If we have no selection, we try automagic.
      # We mark the current *visual* line. 
      # (For continuous wrapping a real line can be many visual lines.)

      nameList = RSI_list_names()

      # Perhaps it's the first time the user calls an RSI macro.  So, if
      # we have no rangesets defined yet, try to get a predefined one.
      if (nameList == "") {
         if (RSI_allocate_predef()) {
            nameList = RSI_list_names()
            names = split(nameList, "\n")
         }
         else
            return
      }
      else {
         # We have rangesets, so we ask:
         # Is the cursor already on a range of a rangeset?
         nameList = RSI_list_names()
         names = split(nameList, "\n")
         for (i = 0; i < names[]; i++) {
            oldId = RSI_get_id(names[i])
            index = rangeset_includes(oldId, $cursor)
            if (index != 0) {
                # Yes we are on a range!
                # Pick up the next best rangeset name.
                j = (i + 1) % names[]
                if (j != i) {
                    newId = RSI_get_id(names[j])
                    r = rangeset_range(oldId, index)
                    # remove range from current set
                    rangeset_subtract(oldId, r["start"], r["end"])
                    # and add range to next set
                    rangeset_add(newId, r["start"], r["end"])
                    return
                }
                else {
                    # If we are here, we have only one rangeset defined.
                    # We ask user.
                    name = RSI_ask_for_name("Add selected text to rangeset:\n\n"\
                              "Choose Rangeset\n"\
                              "(choosing NEW lets you create a new one)", "NEW")
                }
            }
         }
      }
      # If we reach here, we have at least one rangeset.
      # So, we can go ahead to mark the current visual line.
      pos = $cursor
      beginning_of_line()
      start = $cursor
      end_of_line()
      end = $cursor
      set_cursor_pos(pos)
      if (start == end) end++
      if (0 in names) {
          rId = RSI_get_id(names[0])
          rangeset_add(rId, start, end)
      }
      else {
          dialog("RSI_add: Internal error - no rangeset names?")
      }
  }
  else {
      # We have a selection
      name = RSI_ask_for_name("Add selected text to rangeset:\n\n"\
                "Choose Rangeset\n"\
                "(choosing NEW lets you create a new one)", "NEW")

  

     if(name != "")
       RSI_add_selection( RSI_get_id( name ) )
  }

}

# ----------------------------------------------------------------------
# RSI_remove_selected():
# Remove selected text from a rangeset, which is chosen by dialog. If
# there is no selection, acts automagically, cf. the subsequent comments.
# (This is part of a simple and quick next/previous mark functionality.)
# ----------------------------------------------------------------------

define RSI_remove_selected {

  if ($selection_start == -1) {
     # Is the cursor already on a range of a rangeset?
     # Then this will be the 'selected' one to remove.
     nameList = RSI_list_names()
     names = split(nameList, "\n")
     for (i = 0; i < names[]; i++) {
        rId = RSI_get_id(names[i])
        index = rangeset_includes(rId, $cursor)
        if (index != 0) {
            # Yes we are on a range!
                r = rangeset_range(rId, index)
                # remove range from current set
                rangeset_subtract(rId, r["start"], r["end"])
                return
            }

     }
  }
  else {
      name = RSI_ask_for_name("Remove selected text from rangeset:\n\nChoose Rangeset", "")

      if (name != "")
      {
        rangeset_subtract( RSI_get_id( name ) )
        deselect_all()
      }
  }
}

# ----------------------------------------------------------------------
# RSI_remove_all():
# remove all ranges from a rangeset / all rangesets (chosen by dialog)
# within current window.
# (i.e. clear rangeset)
# ----------------------------------------------------------------------

define RSI_remove_all {
  name = RSI_ask_for_name("Clear marked text\n(i.e. remove all ranges from rangeset):\n\nChoose Rangeset", "ALL")

  if (name != "")
  {
    if (name == "ALL")
    {
      nameList = RSI_list_names()
      names = split(nameList, "\n")
      for(i = 0; i < names[]; i++)
      {
        rangeset_subtract(RSI_get_id(names[i]), 0, $text_length)
      }
    }
    else
    {
      rangeset_subtract(RSI_get_id(name), 0, $text_length)
    }
  }
}

# ----------------------------------------------------------------------
# RSI_color():
# change color of a rangeset, which is chosen by dialog, unless the 
# cursor is located on a rangeset
# ----------------------------------------------------------------------

define RSI_color {
  startPos = $cursor
  idx = 0
  
  # Check if we are on a rangeset
  allRSets = $rangeset_list
  for (i = 0; i < allRSets[] && idx == 0; i++) {
      rId = allRSets[i]
      idx = rangeset_includes(rId, startPos)
  }
  if (idx != 0) {
      # we are on a rangeset
      a = rangeset_info(rId)
      oldColor = a["color"]
      name = a["name"]
      t = search_string(name, $RSI_globals["name-prefix"], 0, "case")
      if (t == 0) {
        # the rangeset is defined by the RSI macros, because its name has the prefix
        name = substring(name, $search_end, length(name))
        color = RSI_choose_color(name, oldColor, 0)
        RSI_set_color( name, color )
      }
      else {
        # rangeset is externally defined (by other macros, not RSI macros)
        # pass and use its ID directl, not the name
        color = RSI_choose_color("", oldColor, 0, rId)
        rangeset_set_color(rId, color)
      }
  }
  else {
      # we are not on a rangeset, so ask for one (defined by RSI only)
      name = RSI_ask_for_name("Change color:\n\nChoose Rangeset", "")

      if (name != "")  {
        oldColor = RSI_get_color(name)
        color = RSI_choose_color(name, oldColor, 0)
        RSI_set_color( name, color )
      }
  }
}

# ----------------------------------------------------------------------
# RSI_rename():
# rename an existing rangeset, which is chosen by dialog
# ----------------------------------------------------------------------

define RSI_rename {
  
  # oldName exists, because it is chosen from the dialog!
  oldName = RSI_ask_for_name("Rename:\n\nChoose Rangeset", "")

  if (oldName != "")
  {
    while(1)
    {
      newName = string_dialog( "New Name of Rangeset:", "OK", "Cancel" )

      if($string_dialog_button == 1)
      {
        if (RSI_verify_name(newName))
        {
              # or just rename in this window
              RSI_rename_in_window(oldName, newName)

          return
        }
        else
        {
          if (oldName == newName)
            return
          if (newName != "")
            dialog("Name <" newName "> already defined.\nPlease choose another one.", "OK")
        }
      }
      else
        return
    }
  }
  else 
    dialog("Nothing to rename.")
}

# ----------------------------------------------------------------------
# RSI_destroy():
# destroy existing rangeset(s) (chosen by dialog)
#  "All" means, all those defined by RSI.
# ----------------------------------------------------------------------

define RSI_destroy {
  name = RSI_ask_for_name("Choose Rangeset to destroy", "ALL")
  if (name != "")
  {
    if (name == "ALL")
    {
      nameList = RSI_list_names()
      names = split(nameList, "\n")
      
      for (i = 0; i < names[]; i++)
      {
        RSI_destroy_name(names[i])
      }
    }
    else
    {
      RSI_destroy_name(name)
    }
  }
}
# ----------------------------------------------------------------------
# RSI_destroy_any():
# real destroy all rangesets in the window including
#  those not defined by RSI
# ----------------------------------------------------------------------
define RSI_destroy_any {
 r = $rangeset_list
 rangeset_destroy(r)
}

# ----------------------------------------------------------------------
# RSI_save():
# save information of all rangesets defined in current window
# ----------------------------------------------------------------------

define RSI_save {
  storageType = dialog("Save Rangset Info:\nPlease select storage location.", "Inline", "Extra File", "Cancel")

  if (storageType == 1)
  {
    RSI_store_inline()
  }
  else if (storageType == 2)
  {
    RSI_store_in_file()
  }
}

# ----------------------------------------------------------------------
# RSI_load():
# load rangeset information and apply it on current window
# ----------------------------------------------------------------------

define RSI_load {

  storageType = dialog("Load Rangset Info:\nPlease select source location.", "Inline", "Extra File", "Cancel")

  if (storageType == 1)
  {
    RSI_read_inline()
  }
  else if (storageType == 2)
  {
    RSI_read_from_file()
  }
}

# ----------------------------------------------------------------------
# RSI_find_all():
# find all occurrences of a string and add them to a rangeset named
# "Found".  If this rangeset doesn't exist, another one must be
# chosen by dialog.  The text to be searched as well as the
# mode of search is chosen by dialog.
# ----------------------------------------------------------------------

define RSI_find_all {
  type       = "case"

  findString = string_dialog("Find string", "Case", "Literal", "Regex", "Dismiss")

  if (findString == "")
    return

  if ($string_dialog_button == 1)
    type = "case"
  else if ($string_dialog_button == 2)
    type = "literal"
  else if ($string_dialog_button == 3)
    type = "regex"
  else
    return

  # silently initialize
  nameList = RSI_list_names()
  if (nameList == "") {
     if (RSI_allocate_predef())
        nameList = RSI_list_names()
     else
        return
  }
     
  # If there, use Found rangeset, else ask
  r = rangeset_get_by_name($RSI_globals["name-prefix"]"Found")
  ask = 1
  if (r[] == 1) {
     a = rangeset_info(r[0])
     ask = a["count"]
  }
  # Here ask is 0 (= False) iff there is exactly one rangeset named "Found"  
  # AND this rangeset is unused (ie, there are no ranges in the Found rangeset)
  if (ask) {
      name = RSI_ask_for_name("Choose rangeset to add the matches to.\n"\
                              "(choosing NEW lets you create a new one)", "NEW")

      if (name == "")
        return
  }
  else {
     name = "Found"
  }
  id = RSI_get_id(name)
  pos = 0
  for (pos = search(findString, 0, type); pos != -1; pos = search(findString, pos, type))
  {
    rangeset_add(id, pos, $search_end)
    pos = $search_end
  }
}


# ----------------------------------------------------------------------
# RSI_goto_next(direction):
# Goto start of a range next to the current cursor position.
# 
# If direction > 0, jumps to the next range (marked line) regardless of color.
# If direction < 0, jumps to the previous range.
# Returns nothing but sets mark(9) if the cursor wasn't on a range so you can 
# go back.
# ----------------------------------------------------------------------
define RSI_goto_next {
 direction = $1

 nameList = RSI_list_names()
 if (nameList == "") {
     dialog("No Rangesets defined, yet.")
     return
 }

 names = split(nameList, "\n")
 # create a single temporary rangeset, add all rangeset to it, so that
 # we have the ranges in this rangesets ordered by index. Hence we can
 # easily jump to the next/previous range from cursor position.
 tmpRS = rangeset_create()
 if (tmpRS == 0) {
     dialog("RSI_goto_next:  No new rangeset available.")
     return
 }
 for (i = 0; i < names[]; i++) {
     rId = RSI_get_id(names[i])
     d = rangeset_info(rId)
     if (d["count"] != 0) 
         rangeset_add(tmpRS, rId)
 }

 a = rangeset_info(tmpRS)
 previous = 0
 next = 0
 for (i = 1; i <= a["count"]; i++) {
     r = rangeset_range(tmpRS, i)
     if (r["start"] < $cursor) {
         previous = i
     }
     else {
      next = i
      if (r["start"] == $cursor) {
         if (next == a["count"]) next = 1
             else next++
      }
      break
      }
 }
 if (direction < 0) {
 # goto previous
 if (previous == 0) previous = a["count"]
 r = rangeset_range(tmpRS, previous)
 }
 else {
 if (next == 0) next++
 r = rangeset_range(tmpRS, next)
 }
 if (r[] != 0) {
     idx = 0
     for (i = 0; i < names[] && idx == 0; i++) {
         rId = RSI_get_id(names[i])
         idx = rangeset_includes(rId, $cursor)
     }
     if (idx == 0) {
         mark(9)
     }
     set_cursor_pos(r["start"])
     if (jf_require("utilities.nm") == "")
         centerline()
 }
 else {
     dialog("No markers defined yet")
 }
 rangeset_destroy(tmpRS)
}


# ----------------------------------------------------------------------
# RSI_goto_next_choose():
# Goto start of a range which is part of a rangeset and which is
# located next to current cursor position in forward direction.
# The rangeset is selected by dialog, if current cursor position
# is not located inside a rangeset.
# ----------------------------------------------------------------------

define RSI_goto_next_choose {
  startPos = $cursor
  idx = 0

  allRSets = $rangeset_list
  if (allRSets[] == 0) {
      dialog("No Rangesets defined, yet.")
      return
  }
  for (i = 0; i < allRSets[] && idx == 0; i++) {
      rId = allRSets[i]
      idx = rangeset_includes(rId, startPos)
  }


  if (idx == 0)
  {
    # -- cursor not located within any rangeset:
    # -- ask user for rangeset to goto
    name = RSI_ask_for_name("Goto next range:\n\nChoose rangeset", "")
    if (name == "")
      return

    rId = RSI_get_id( name )

    nextPos = RSI_get_next_pos(rId, startPos, 1)
  }
  else
  {
    nextPos = RSI_get_next_pos(rId, rangeset_range( rId, idx )["end"] + 1, idx+1)
  }

  if (nextPos == -1 || startPos == nextPos)
    beep()
  else
  {
    if (startPos > nextPos)
      beep()

    set_cursor_pos (nextPos)
    if (jf_require("utilities.nm") == "")
        centerline()
  }
}

# ----------------------------------------------------------------------
# RSI_goto_prev():
# Goto start of a range which is part of a rangeset and which is
# located next to current cursor position in backward direction.
# The rangeset is selected by dialog, if current cursor position
# is not located inside a rangeset.
# ----------------------------------------------------------------------

define RSI_goto_prev {
  startPos = $cursor
  idx = 0

  allRSets = $rangeset_list
  if (allRSets[] == 0) {
      dialog("No Rangesets defined, yet.")
      return
  }
  for (i = 0; i < allRSets[] && idx == 0; i++) {
      rId = allRSets[i]
      idx = rangeset_includes(rId, startPos)
  }


  if(idx == 0)
  {
    # -- cursor not located within any rangeset:
    # -- ask user for rangeset to goto
    name = RSI_ask_for_name("Goto previous range:\n\nChoose rangeset", "")
    if (name == "")
      return

    rId = RSI_get_id(name)

    prevPos = RSI_get_prev_pos(rId, startPos, -1)
  }
  else
  {
    prevPos = RSI_get_prev_pos(rId, rangeset_range(rId, idx)["start"], idx - 1)
  }

  if (prevPos == -1 || startPos == prevPos)
    beep()
  else
  {
    if (startPos < prevPos)
      beep()

    set_cursor_pos(prevPos)
    if (jf_require("utilities.nm") == "")
        centerline()
  }
}

#==================================================================================
# RSI_wdiff_dialog()
# select to files and open a new window showing the differences between these files
# using RSI_show_changes()
#==================================================================================
define RSI_wdiff_dialog {
 path = $file_path
 fileFrom = filename_dialog("wDiff:\nSelect the first file:", "exist", path)
 if (fileFrom == "")
    return

 if (jf_require("utilities.nm") == "") {
     path = mk_extract_pathname(fileFrom)
 }
 fileTo = filename_dialog("wDiff:\nSelect the second file:", "exist", path)
 if (fileTo == "")
    return
 RSI_show_changes(fileFrom, fileTo)
}

# ----------------------------------------------------------------------
# RSI_show_changes([fileFrom, fileTo]): opens a new window showing changes 
# either between the two given files or between
# the current editor window buffer and the file it represents.
# Notice, it depends on GNU wdiff!
# ----------------------------------------------------------------------

define RSI_show_changes {
 # This subroutine uses wdiff to get the differences
 
 # wdiff outputs changes as: This was [- deleted -] {+ added +}. Do you see?
 # we replace [-  with delStart, -] with delEnd, ...
 # to ensure that these signs aren't in the text by accident
 delStart = $sub_sep"\a"
 delEnd   = "\a"$sub_sep
 addStart = $sub_sep"\v"
 addEnd   = "\v"$sub_sep

 if ($n_args == 2) {
    fileFrom = $1
    fileTo = $2
    wdiffCmd = "wdiff -w "delStart" -x "delEnd" -y "addStart" -z "addEnd" "fileFrom" "fileTo
    diffTxt = shell_command(wdiffCmd, "")
 }
 else {
    # No files given, show changes between current buffer and
    # file saved on disk
    fileFrom = $file_path $file_name
    fileTo = ""
    buffer = get_range(0, $text_length)
    wdiffCmd = "wdiff -w "delStart" -x "delEnd" -y "addStart" -z "addEnd" "fileFrom" -"
    diffTxt = shell_command(wdiffCmd, buffer)
 }

 if ($shell_cmd_status > 1)  {
   dialog("The difference command returned an error status:\n" \
          "Command: " wdiffCmd "\n" \
          "Status: " $shell_cmd_status "\n" \
          "Output: " diffTxt)
   return
 }

 if ($shell_cmd_status == 0)  {
   dialog("No differences found between\n" fileFrom "\n" fileTo)
   return
 }

 # get rid of delStart, delEnd, ...
 text = replace_in_string(diffTxt, delStart"|"addStart"|"delEnd"|"addEnd, "", "regex", "copy")

 # Now, put the text in a new window, and color the additions and
 # deletions with two rangesets.
 
 # for syntax highlighting
 lm = $language_mode
 cpos = $cursor
 new("window")
 focus_window("last")
 replace_range(0, $text_length, text)
 set_language_mode(lm)
 set_cursor_pos(cpos)

 # In a new window we have no rangesets yet.
 RSI_allocate_new("Add","#AAFFAA" )
 RSI_allocate_new("Delete", "#FFAAAA")

 add = RSI_get_id("Add")
 del = RSI_get_id("Delete")

 # We got rid of delStart, delEnd, addStart, addEnd from diffTxt,
 # since we have rangesets to mark the additions and deletions, respectively.
 # Since diffTxt is the whole text, ie, the buffer + all changes between
 # buffer and the file, diffTxt may be large.  Since NEdit macros have no
 # garbage collection for strings, we did a single replace_in_string().

 # Notice: all of delStart, delEnd, addStart, addEnd must have the same length.
 incr = length(delStart)
 offset = 0

 # To do the coloring we search for the positions of the additions and
 # deletions, adjusted to the fact that the strings delStart, delEnd, ...
 # got removed from diffTxt.
 addDelPat = "(?n"addStart".+?"addEnd"|"delStart".+?"delEnd")"
 found = search_string(diffTxt, addDelPat, 0, "regex")
 while (found != -1) {
     next = $search_end

     type = substring(diffTxt, found, found + incr)

     if (type == addStart) {
         rId = add
     }
     else if (type == delStart) {
         rId = del
     }
     else {
         # Error
         dialog("Error")
         return
     }
     # use offset before this match happened
     start = found - offset

     # Two of delStart, delEnd, ... will be removed at each found pos.
     # incr is the commom length of delStart, delEnd, ...
     offset += 2*incr
     end = next - offset

     # coloring
     rangeset_add(rId, start, end)

     #next
     found = search_string(diffTxt, addDelPat, next, "regex")
 }

}

# ======================================================================
# === Sub procedures ===================================================
# ======================================================================

define RSI_list_names {
 prefix = $RSI_globals["name-prefix"]
 r = $rangeset_list
 nameList = ""
 for (i = 0; i < r[]; i++) {
     a = rangeset_info(r[i])
     if (search_string(a["name"], prefix, 0, "case") == 0) {
        # found a rangeset with name prefixed by RSI
        nameList = nameList a["name"] "\n"
     }
 }
 # remove prefix ->  !!! prefix may need to get escaped !!!
 if (jf_require("utilities.nm") == "")
    prefix = jf_quote_literal_as_regex(prefix)
 
 nameList = replace_in_string(nameList, "^"prefix, "", "regex", "copy")
 # remove trailing \n
 if (length(nameList) > 0)
    nameList = substring(nameList, 0, length(nameList) - 1)
 
 return nameList
}


# ----------------------------------------------------------------------
# RSI_ask_for_name(infoText, mode):
# select a name of a rangeset.
# Parameters:
# $1 = list dialog info text
# $2 = mode:
#        "NEW" -> allow creation of new rangesets
#        "ALL" -> allow selection of all rangesets
# returns: name of rangeset (empty string, if none was chosen)
# ----------------------------------------------------------------------

define RSI_ask_for_name {
  dialogTitle = $1
  mode = $2
  selName = ""
  
  nameList = RSI_list_names()
  
  # If we have no rangesets yet, allocate the predefined ones
  if (nameList == "") {
     if (RSI_allocate_predef()) {
        nameList = RSI_list_names()
     }
  }
  if (mode != "")
    nameList = mode"\n"nameList

  if (nameList != "") {
      selName = list_dialog( dialogTitle, nameList, "OK", "Cancel")

      if($list_dialog_button == 2) {
        return ""
      }

      if(selName == "NEW") {
        selName = RSI_define_new()
      }

      return selName
  }
  else {
      return ""
  }
}

# ----------------------------------------------------------------------
# RSI_verify_name(name):
# verify if given name is valid for rangeset (e.g. check for duplicates).
# Parameters:
# $1 = name to be verified (without prefix!)
# returns: 1, if verification is successful, else 0.
# ----------------------------------------------------------------------

define RSI_verify_name {
  name = $1
  if (name == "")
    return 0

  # name is ensured to be non-empty
  return !RSI_exists(name)
}

# ----------------------------------------------------------------------
# RSI_get_id(name)
# get ID of rangeset of current window whose name matches "name"
# Parameters:
# $1 = name of rangeset (without prefix)
# returns: ID of rangeset  (no match, returns 0)
# ----------------------------------------------------------------------

define RSI_get_id {
  name = $1
  if (name != "") {
      name = $RSI_globals["name-prefix"] name
  }
  rIdArray = rangeset_get_by_name(name)
  if (rIdArray[] == 1)  {
      return rIdArray[0]
  }
  else {
      return 0
  }
}

# ----------------------------------------------------------------------
# RSI_rename_in_all_windows(oldName, newName)
# rename rangeset named "oldName" to "newName" within all windows.
# Parameters:
# $1 = old name  (without prefix)
# $2 = new name  (without prefix)
# none
# returns: ---
# ----------------------------------------------------------------------

define RSI_rename_in_all_windows {

  oldName = $1
  newName = $2
  
  startWindowId = $file_path $file_name
  currentWindowId = startWindowId
  endOfWindow = 0

  while (!endOfWindow)
  {
    RSI_rename_in_window(oldName, newName)
    currentWindowId = focus_window("next")
    if (currentWindowId == "")
      currentWindowId = focus_window("last")

    if (currentWindowId == startWindowId)
      endOfWindow = 1
  }
}

# ----------------------------------------------------------------------
# RSI_rename_in_window(oldName, newName)
# rename rangeset named "oldName" to "newName" within current window.
# Parameters:
# $1 = old name   (without prefix)
# $2 = new name   (without prefix)
# returns: ---
# ----------------------------------------------------------------------

define RSI_rename_in_window {
  oldName = $1
  newName = $2
  
  if (oldName != "") {
     oldName = $RSI_globals["name-prefix"] oldName
  }
  if (newName != "") {
     newName = $RSI_globals["name-prefix"] newName
  }
  

  rIdArray = rangeset_get_by_name(oldName)

  if (rIdArray[] == 1)
  {
    rId = rIdArray[0]
    rangeset_set_name(rId, newName)
  }
  else {
    dialog("RSI_rename_in_window: inconsistent RS names!")
  }
}

# ----------------------------------------------------------------------
# RSI_define_new()
# define a new rangeset by selecting name and color via dialog.
# Parameters:
# ---
# returns: name of new rangeset
# ----------------------------------------------------------------------

define RSI_define_new {

  while(1)
  {
    name = string_dialog( "Name of new Rangeset:", "Create", "Cancel" )

    if($string_dialog_button == 1)
    {
      if (RSI_verify_name(name))
      {
        color = RSI_choose_color(name, "-", 1)
        if (color == "-")
          return ""

        if(!RSI_allocate_new(name, color))
        {
          return ""
        }

        return name
      }
      else
      {
        if (name != "")
          dialog("Name <" name "> already defined.\nPlease choose another one.", "OK")
      }
    }
    else
    {
      return ""
    }
  }
}

# ----------------------------------------------------------------------
# RSI_allocate_new(name, color)
# allocate a new rangeset of name "name"; assign given color to new
# rangeset.
# Parameters:
# $1 = name of range set
# $2 = color of range set
# returns: 1, if rangeset could be allocated, else 0.
# ----------------------------------------------------------------------

define RSI_allocate_new {

    color = $2
    name = $1
    if (name != "") 
        name = $RSI_globals["name-prefix"] name
    
    # check if name already exists
    rId = rangeset_get_by_name(name)
    if (rId[] != 0) {
        return
    }
    
    rId = rangeset_create()

    if(rId == 0)
    {
      dialog( "Sorry:\n\nNo more rangesets available", "OK" )
      return 0
    }

    rangeset_set_color(rId, color)
    rangeset_set_name(rId, name)

    return 1
}

# ----------------------------------------------------------------------
# RSI_destroy_name(name)
# Destroy rangeset identified by "name" within current window.
# Parameters:
# $1 = name of rangeset (without prefix)
# returns: ---
# ----------------------------------------------------------------------

define RSI_destroy_name {

  name = $1
  if (name != "") {
     name = $RSI_globals["name-prefix"] name
  }
  else {
    return
  }
  rIdArray = rangeset_get_by_name(name)
  rangeset_destroy(rIdArray)

}

# ----------------------------------------------------------------------
# RSI_destroy_name_all(name)
# Destroy rangeset identified by "name" within all windows.
# Parameters:
# $1 = name of rangeset (without prefix)
# returns: ---
# ----------------------------------------------------------------------

define RSI_destroy_name_all {

  name = $1
  if (name != "") {
     name = $RSI_globals["name-prefix"] name
  }
  else {
    return
  }
  
  currentWindowId = $file_path $file_name

  startWindowId = currentWindowId
  endOfWindow = 0

  while (!endOfWindow)
  {
    rIdArray = rangeset_get_by_name(name)

      rangeset_destroy(rIdArray)

    currentWindowId = focus_window("next")
    if (currentWindowId == "")
      currentWindowId = focus_window("last")

    if (currentWindowId == startWindowId)
      endOfWindow = 1
  }

  focus_window( currentWindowId )
}

# ----------------------------------------------------------------------
# RSI_select(selectionParamArray)
# select some text specified by "selectionParamArray".
# Parameters:
# $1 = array with selection parameters ("start", "end", "left", "right")
# returns: ---
# ----------------------------------------------------------------------

define RSI_select {
  sel = $1
  if (sel["left"] != -1)
    select_rectangle(sel["start"], sel["end"], sel["left"], sel["right"])
  else if (sel["start"] != -1)
    select(sel["start"], sel["end"])
}

# ----------------------------------------------------------------------
# RSI_choose_color(name, oldColor, newFlag)
# select (via dialog) and assign a color to rangeset identified
# by given "name".
# The "try" color creates
# Parameters:
# $1 = name of rangeset (without prefix)
# $2 = old color
# $3 = new rangeset flag (1 = new rangeset)
# $4 = ID of an externally defined rangeset (optional)
# returns: name of selected color
# ----------------------------------------------------------------------

define RSI_choose_color {
  name = $1
  appliedColor = $2
  newRS = $3
  
  # We like to allow the color choose dialog also for rangesets that
  # are not defined by the RSI macros.  In this case such a rangeset
  # must be given directly with its Id.
  if (name == "" && $n_args == 4) {
      rId = $4
      a = rangeset_info(rId)
      externalName = a["name"]
  }
  else {
      rId = 0
      externalName = ""
  }
  chosen = 0
  byListDialog = 1
  rsAvailable = 0
  triedColor = ""
  sel["start"] = $selection_start
  sel["end"]   = $selection_end
  sel["left"]  = $selection_left
  sel["right"] = $selection_right

  preDefColorList = read_file($RSI_globals["color-list"])
  if (preDefColorList == "")
    dialog("Warning: no predefined colors available.\nFile <"\
           $RSI_globals["color-list"] "> not existing ?", "OK")

  if (sel["start"] != -1)
  {
    # if there is a selection, a new rangeset is created
    rId = rangeset_create()
    # the selection is added as range to this rangeset
    RSI_add_selection(rId)
    RSI_select(sel)
    rsAvailable = 1
  }
  else if (!newRS)
  {
    # no selection and no new RS
    if (name != "" && rId == 0) {
        rId = RSI_get_id(name)
    }
    rsAvailable = 1
  }

  while (!chosen)
  {
      if (appliedColor == "")
        dialogColor = "NONE"
      else
        dialogColor = appliedColor

      # For an external RS, ie, one not defined by RSI macros, we choose its name
      if (name == "") {
          name = externalName
      }
      if (name == "") {
          name = "<>"
      }
      dialogText = "Choose color for rangeset '" name "'\n(current chosen color = " dialogColor "):"

      if (preDefColorList == "")
      {
        color = string_dialog(dialogText, "OK", "Try", "Cancel")
        buttonSelected = $string_dialog_button
        if (buttonSelected > 1)
          buttonSelected ++
      }
      else if (byListDialog)
      {
        color = list_dialog(dialogText, preDefColorList, "OK", "Other", "Try", "Cancel")
        buttonSelected = $list_dialog_button
      }
      else
      {
        color = string_dialog(dialogText, "OK", "Predefined", "Try", "Cancel")
        buttonSelected = $string_dialog_button
      }

      if (buttonSelected == 1)
      {
        if (appliedColor != "" && color == "")
          color = appliedColor
        chosen = 1
      }
      else if (buttonSelected == 2)
      {
        byListDialog = !byListDialog
      }
      else if (buttonSelected == 3)
      {
        deselect_all()
        if (rsAvailable)
        {
          rangeset_set_color(rId, color)
        }
        appliedColor = color
      }
      else
      {
        color = $2
        chosen = 1
      }
  }

  if (sel["start"] != -1)
  {
    rangeset_destroy(rId)
  }

  RSI_select(sel)

  return color
}

# ----------------------------------------------------------------------
# RSI_get_color(name):
# get color of rangeset identified by "name".
# Parameters:
# $1 = name of rangeset  (without prefix)
# returns: color of rangeset
# ----------------------------------------------------------------------

define RSI_get_color {

 name = $1
 if (name != "")
     name = $RSI_globals["name-prefix"] name
 r = $rangeset_list

 for (i = 0; i < r[]; i++) {
     a = rangeset_info(r[i])
     if ( name == a["name"] ) {
        # found a rangeset with that name
        return a["color"]
     }
 }
 # if we reach here, name wasn't found
 return ""
}

# ----------------------------------------------------------------------
# RSI_set_color(name, color):
# assign given "color" to rangeset identified by "name"
# Parameters:
# $1 = name of rangeset (without prefix)
# $2 = color
# returns: ---
# ----------------------------------------------------------------------

define RSI_set_color {

 name = $1
 color = $2
 if (name != "") {
    name = $RSI_globals["name-prefix"] name
 }
 
 r = rangeset_get_by_name(name)
 
 if (r[] == 1) {
    rangeset_set_color(r[0], color)
 }
 
}

# ----------------------------------------------------------------------
# RSI_add_selection(rangesetId):
# add selected text to rangeset specified by "rangesetId".
# Parameters:
# $1 = ID of rangeset
# returns: ---
# ----------------------------------------------------------------------

define RSI_add_selection {
  if ($selection_left == -1)
    rangeset_add($1)
  else
  {
    # Rectangular selection: add line by line

    # to determine start of line:
    lineEndPos = search("\n", $selection_start, "backward")

    while (lineEndPos < $selection_end)
    {
      # determine start of line
      lineStartPos = lineEndPos + 1

      # determine end of line
      lineEndPos = search("\n", lineStartPos)

      # determine subrange start pos.
      pos = lineStartPos + $selection_left

      if (pos < lineEndPos)
      {
        if (lineEndPos == -1)
          lineEndPos = $text_length
# returns: ---

        # determine endPos of subrange:
        # is $selection_right behind line end ?
        # set subrange end to lineEnd in this case
        posEnd = lineStartPos + $selection_right

        if (posEnd > lineEndPos)
          posEnd = lineEndPos

        #add the subrange
        rangeset_add($1, pos, posEnd)
      }
    }
  }
  deselect_all()
}


# ----------------------------------------------------------------------
# RSI_get_next_pos(rangesetId, cursorPos, rangeIndex):
# determine start position of range, which is located next to given
# cursor position "cursorPos" in forward direction.
# Parameters:
# $1 = ID of rangeset
# $2 = cursor pos. to start with
# $3 = range index to start with
# returns: start position of next range
# ----------------------------------------------------------------------

define RSI_get_next_pos {

  rId = $1
  pos = $2

  info = rangeset_info( rId )

  nbrOfRanges = info["count"]

  for (i = $3; i <= nbrOfRanges; i++)
  {
    range = rangeset_range( rId, i )

    if (range["end"] >= pos)
      return range["start"]
  }

  # -- no range after "pos" ->
  # -- select 1st range, if any exists
  if (nbrOfRanges == 0)
    return -1
  else
    return rangeset_range(rId, 1)["start"]
}

# ----------------------------------------------------------------------
# RSI_get_prev_pos(rangesetId, cursorPos, rangeIndex):
# determine start position of range, which is located next to given
# cursor position "cursorPos" in backward direction.
# Parameters:
# $1 = ID of rangeset
# $2 = cursor pos. to start with
# $3 = range index to start with (-1 -> start with last one)
# returns: start position of previous range
# ----------------------------------------------------------------------

define RSI_get_prev_pos {

  rId = $1
  pos = $2

  info = rangeset_info(rId)

  nbrOfRanges = info["count"]

  if ($3 == -1)
    startIdx = nbrOfRanges
  else
    startIdx = $3

  for (i = startIdx; i >= 1; i--)
  {
    range = rangeset_range(rId, i)

    if (range["end"] <= pos)
      return range["start"]
  }

  # -- no range after "pos" ->
  # -- select last range, if any exists
  if (nbrOfRanges == 0)
    return -1
  else
    return rangeset_range(rId, nbrOfRanges)["start"]
}



# ----------------------------------------------------------------------
# RSI_exists(name):
# check, if rangeset specified by name (without prefix) is defined.
# Parameters:
# $1 = name of rangeset
# returns: 1, if rangeset exists, else 0
# ----------------------------------------------------------------------

define RSI_exists {
 name = $1
 if ( name != "") {
    name = $RSI_globals["name-prefix"] name
 }
 else {
    dialog("RSI_exists: Internal Error, name shouldn't be empty")
 }
 
 r = $rangeset_list

 for (i = 0; i < r[]; i++) {
     a = rangeset_info(r[i])
     if ( name == a["name"] ) {
        # found a rangeset with that name
        return 1
     }
 }
 # if we reach here, name wasn't found
 return 0
}

# ----------------------------------------------------------------------
# RSI_store_inline():
# store rangeset info inside current window (XML style)
# returns: ---
# ----------------------------------------------------------------------

define RSI_store_inline {

  # -- look for an already existing rangeset-info block
  # -- in current buffer

  buffer = get_range(0, $text_length)

  rsiBlock = RSI_read_block(buffer, "rangeset-info", 0)

  if (rsiBlock["eobPos"] != -1)
  {
    out = RSI_write(0)

    startReplace = rsiBlock["startContPos"]
    endReplace   = startReplace + length(rsiBlock["content"])

    replace_range(startReplace, endReplace, out)
  }
  else
  {
    out = RSI_write(1)

    if ($language_mode == "CHILL" || \
        $language_mode == "CHILL Sourceman" || \
        $language_mode == "C++" || \
        $language_mode == "C")
    {
      out = "/**************\n" out "*************/\n"
    }

    currentPos = $cursor
    end_of_file()
    insert_string("\n" out)
    set_cursor_pos(currentPos)
  }
}

# ----------------------------------------------------------------------
# RSI_store_in_file():
# store rangeset info within an extra file (XML style)
# returns: ---
# ----------------------------------------------------------------------

define RSI_store_in_file {
  out = RSI_write(1)

  defName = $file_name ".rsi"

  title = "Save Rangeset Info - Select File"
  path = $file_path
  default_filename = defName
  filter = "*.rsi"
  mode = "new"
  fileName = filename_dialog(title, mode, path, filter, default_filename)

  if (fileName != "")
  {
    write_file(out, fileName)
  }
}

# ----------------------------------------------------------------------
# RSI_write(includeBlockFlag)
# create a rangeset-info string holding info of all rangesets of
# current window.
# Parameters:
# $1 = "include <rangeset-info> block" flag (1=include; 0=exclude)
# returns: return "rangeset-info" string
# ----------------------------------------------------------------------

define RSI_write {

  if ($1 == 1)
    out = "<rangeset-info>\n"
  else
    out = "\n"

  names = split(RSI_list_names(), "\n")
  for (i=0; i < names[]; i++)
  {
    out = out "  <rangeset>\n"

    name = names[i]
    rId = RSI_get_id(name)
    rInfo = rangeset_info(rId)
    out = out "    <name>" name "</name>\n"
    out = out "    <color>" rInfo["color"] "</color>\n"

    nbrRanges = rInfo["count"]

    for (j=1; j <= nbrRanges; j++)
    {
      range = rangeset_range(rId, j)
      out = out "    <range>\n"
      out = out "      <start>" range["start"] "</start>\n"
      out = out "      <end>"   range["end"]   "</end>\n"
      out = out "    </range>\n"
    }
    out = out "  </rangeset>\n"
  }

 if ($1 == 1)
   out = out "</rangeset-info>\n"

  return out
}

# ----------------------------------------------------------------------
# RSI_read_inline():
# read rangeset info out of rangeset-info block, which is stored
# within current window. Apply read rangeset info to current window.
# returns: ---
# ----------------------------------------------------------------------

define RSI_read_inline {
  RSI_read(get_range(0, $text_length))
}

# ----------------------------------------------------------------------
# RSI_read_from_file():
# read rangeset info from a file (file is selected by dialog).
# Apply read rangeset info to current window.
# returns: ---
# ----------------------------------------------------------------------

define RSI_read_from_file {
  defName = $file_name ".rsi"

  title = "Load Rangeset Info - Select File"
  path = $file_path
  default_filename = defName
  filter = "*.rsi"
  mode = "exist"
  fileName = filename_dialog(title, mode, path, filter, default_filename)

  if (fileName != "")
  {
    input = read_file(fileName)

    RSI_read(input)
  }
}

# ----------------------------------------------------------------------
# RSI_read(stringBuffer):
# read rangeset info from given string buffer and apply it to
# current window.
# Parameters:
# $1 = string buffer to be scanned for rangeset info
# returns: --
# ----------------------------------------------------------------------

define RSI_read {
  block = RSI_read_block($1, "rangeset-info", 0)

  if (block["eobPos"] == -1)
    return

  pos = 0
  rangesetInfo = block["content"]

  while (pos != -1)
  {
    pos = RSI_read_set(rangesetInfo, pos)
  }

}

# ----------------------------------------------------------------------
# RSI_read_set(stringBuffer, startPos):
# read one rangeset from given stringBuffer starting at given start pos.
# Apply read rangeset to current window.
# Parameters:
# $1 = string buffer to be scanned for next rangeset
# $2 = pos. to start scan
# returns: next pos. to continue scan with
# ----------------------------------------------------------------------

define RSI_read_set {

  # -- scan for <rangeset> block
  block = RSI_read_block($1, "rangeset", $2)

  if (block["eobPos"] == -1)
    return -1

  rangeset   = block["content"]
  endOfBlock = block["eobPos"]

  # -- scan for name of rangeset
  block = RSI_read_block(rangeset, "name", 0)
  if (block["eobPos"] == -1)
    return -1

  name = block["content"]

  # -- scan for color of rangeset
  block = RSI_read_block(rangeset, "color", block["eobPos"])
  if (block["eobPos"] == -1)
    return -1

  color = block["content"]

  # -- check, if new rangeset needs to be allocated
  if (RSI_exists(name) == 0)
  {
    RSI_allocate_new(name, color)
  }
  else
  {
    RSI_set_color(name, color)
  }

  # -- scan for range blocks
  pos = block["eobPos"]
  rId = RSI_get_id(name)

  while (pos != -1)
  {
    block = RSI_read_block(rangeset, "range", pos)
    if (block["eobPos"] == -1)
      return endOfBlock

    range = block["content"]
    pos   = block["eobPos"]

    # -- read start pos of range
    block = RSI_read_block(range, "start", 0)
    if (block["eobPos"] == -1)
      return endOfBlock

    startPos = block["content"]

    # -- read end pos of range
    block = RSI_read_block(range, "end", block["eobPos"])
    if (block["eobPos"] == -1)
      return endOfBlock

    endPos = block["content"]

    # -- add range
    rangeset_add(rId, startPos, endPos)
  }

  return endOfBlock
}


# ----------------------------------------------------------------------
# RSI_read_block(stringBuffer, blockTag, startPos):
# read a XML style block identified by blockTag from given stringBuffer
# starting at given start pos.
# Parameters:
# $1 = string buffer to be scanned for next block
# $2 = block tag
# $3 = pos. to start scan
# returns: array holding following elements:
# - "eobPos"       = end of block pos. (= -1 in case of failure)
# - "startContPos" = start pos. of block (= -1 in case of failure)
# - "content"      = content of block
# ----------------------------------------------------------------------

define RSI_read_block {
  blockStartTag = "<" $2 ">"
  blockEndTag   = "</" $2 ">"

  block["eobPos"] = -1

  # -- scan for start of block
  pos = search_string($1, blockStartTag, $3)

  if (pos == -1)
    return block

  pos = pos + length(blockStartTag)

  endPos = search_string($1, blockEndTag, pos)
  if (endPos == -1)
    return block

  block["content"]      = substring($1, pos, endPos)
  block["startContPos"] = pos
  block["eobPos"]       = endPos + length(blockEndTag)

  return block
}

# ----------------------------------------------------------------------
# RSI_get_line_info(stringBuffer):
# determines start and end positions of lines within given
# "stringBuffer".
# Parameters:
# $1 = string buffer
# returns: array holding per line "start" / "end" (inclusive) positions

define RSI_get_line_info {

  # -- determine start / end pos of lines in a string buffer
  lineEndPos = 0
  n          = 1
  pos        = 0
  while (lineEndPos != -1)
  {
    lineEndPos = search_string($1, "\n", pos)

    if (lineEndPos == -1)
    {
      if (pos < length($1))
      {
        linePosInfo[n,"start"] = pos+1
        linePosInfo[n,"end"  ] = length( $1 ) - 1
        # t_print( n ": start = " linePosInfo[n,"start"] "; end = " linePosInfo[n,"end"] "\n")
      }
    }
    else
    {
      linePosInfo[n,"start"] = pos
      linePosInfo[n,"end"  ] = lineEndPos

      # t_print( n ": start = " linePosInfo[n,"start"] "; end = " linePosInfo[n,"end"] "\n")
      n ++
      pos = lineEndPos + 1
    }
  }

  return linePosInfo
}
